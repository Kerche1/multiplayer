<!DOCTYPE html>
<html>
<head>
  <title>üåê Multi-Control Pro</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="/socket.io/socket.io.js" defer></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: Arial; background: #1a1a1a; color: white; height: 100vh; overflow: hidden; }
    #app { display: flex; height: 100vh; }
    #screen-container { 
      flex: 1; position: relative; background: #000; overflow: hidden; 
      touch-action: none; /* –î–ª—è –ø–∏–Ω—á-–∑—É–º */
    }
    #screen-video { 
      width: 100%; height: 100%; object-fit: contain; transition: transform 0.1s; 
    }
    #cursor-canvas { 
      position: absolute; top: 0; left: 0; pointer-events: none; z-index: 10; 
    }
    #sidebar { 
      width: 300px; background: #2a2a2a; padding: 15px; overflow-y: auto; 
      border-left: 1px solid #444;
    }
    .btn { padding: 10px 15px; margin: 5px; border: none; border-radius: 5px; cursor: pointer; background: #007bff; color: white; }
    .btn:hover { background: #0056b3; }
    .btn:disabled { background: #555; cursor: not-allowed; }
    #controls input { width: 100px; padding: 5px; margin: 5px 0; }
    #chat { height: 200px; background: #3a3a3a; border-radius: 8px; padding: 10px; overflow-y: auto; margin: 10px 0; }
    .status { padding: 10px; background: #444; border-radius: 5px; margin: 10px 0; }
    @media (max-width: 768px) { #sidebar { width: 100%; height: 40%; position: fixed; bottom: 0; } }
  </style>
</head>
<body>
  <div id="app">
    <div id="screen-container">
      <video id="screen-video" autoplay muted playsinline></video>
      <canvas id="cursor-canvas"></canvas>
    </div>
    <div id="sidebar">
      <div class="status" id="status">‚è≥ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</div>
      <div id="controls">
        <input id="roomId" value="room1" placeholder="–ö–æ–¥ –∫–æ–º–Ω–∞—Ç—ã">
        <br>
        <button class="btn" onclick="joinRoom()">üöÄ –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
        <button class="btn" id="startScreenBtn" onclick="toggleScreenShare()" disabled>üì∫ –ü–æ–¥–µ–ª–∏—Ç—å—Å—è —ç–∫—Ä–∞–Ω–æ–º</button>
        <div>üë• <span id="users">0</span> | üé® <span id="myColor">-</span></div>
      </div>
      <div id="chatContainer">
        <div>üí¨ –ß–∞—Ç</div>
        <div id="chat"></div>
        <input id="chatInput" placeholder="–°–æ–æ–±—â–µ–Ω–∏–µ..." onkeypress="handleEnter(event)">
        <button class="btn" onclick="sendChat()">üì§</button>
      </div>
    </div>
  </div>

  <script>
    const socket = io();
    const video = document.getElementById('screen-video');
    const canvas = document.getElementById('cursor-canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('screen-container');
    
    let roomId = 'room1';
    let myPeer = null;
    let currentPeer = null;
    let screenStream = null;
    let scale = 1;
    let isPinching = false;
    let myColor = '#ff4444';
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è canvas
    function resizeCanvas() {
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // WebRTC Peer Connection
    function createPeerConnection(targetId) {
      const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
      const peer = new RTCPeerConnection(config);
      
      peer.ontrack = (event) => {
        video.srcObject = event.streams[0];
      };
      
      peer.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit('ice-candidate', { targetId, candidate: event.candidate });
        }
      };
      
      return peer;
    }

    // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∫–æ–º–Ω–∞—Ç–µ
    async function joinRoom() {
      roomId = document.getElementById('roomId').value;
      socket.emit('join-room', { roomId, userData: { name: 'User' + Math.floor(Math.random()*100) } });
      document.getElementById('status').textContent = `‚è≥ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ ${roomId}...`;
    }

    // –¢—Ä–∞–Ω—Å–ª—è—Ü–∏—è —ç–∫—Ä–∞–Ω–∞
    async function toggleScreenShare() {
      if (screenStream) {
        screenStream.getTracks().forEach(track => track.stop());
        screenStream = null;
        document.getElementById('startScreenBtn').textContent = 'üì∫ –ü–æ–¥–µ–ª–∏—Ç—å—Å—è —ç–∫—Ä–∞–Ω–æ–º';
        video.srcObject = null;
        return;
      }

      try {
        screenStream = await navigator.mediaDevices.getDisplayMedia({ 
          video: { width: { ideal: 1920 }, height: { ideal: 1080 } },
          audio: true 
        });
        
        document.getElementById('startScreenBtn').textContent = 'üõë –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å';
        
        // –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å—Ç—Ä–∏–º –≤—Å–µ–º –≤ –∫–æ–º–Ω–∞—Ç–µ
        socket.emit('offer', { targetId: 'all', offer: await myPeer.createOffer() });
      } catch(err) {
        alert('–û—à–∏–±–∫–∞ —ç–∫—Ä–∞–Ω–∞: ' + err.message);
      }
    }

    // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ (–ø–∏–Ω—á-–∑—É–º –¥–ª—è —Ç–µ–ª–µ—Ñ–æ–Ω–æ–≤)
    let lastDistance = 0;
    container.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        isPinching = true;
        lastDistance = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
      }
    });

    container.addEventListener('touchmove', (e) => {
      if (isPinching && e.touches.length === 2) {
        e.preventDefault();
        const distance = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        const delta = distance / lastDistance;
        scale *= delta;
        scale = Math.max(0.5, Math.min(scale, 3)); // –õ–∏–º–∏—Ç—ã –∑—É–º–∞
        
        video.style.transform = `scale(${scale})`;
        lastDistance = distance;
      }
    });

    container.addEventListener('touchend', () => isPinching = false);

    // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (–∫–ª–∏–∫–∏ –≤—Å–µ—Ö —Ä–∞–±–æ—Ç–∞—é—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ)
    ['click', 'touchstart'].forEach(event => {
      container.addEventListener(event, (e) => {
        e.preventDefault();
        const rect = container.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        
        // –û—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–ª–∏–∫ –≤—Å–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞–º
        socket.emit('remote-input', {
          roomId,
          type: 'click',
          x: x / rect.width,
          y: y / rect.height,
          scale
        });
        
        // –í—ã–ø–æ–ª–Ω–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω–æ
        executeInput({ type: 'click', x, y });
      }, { passive: false });
    });

    // –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –∫—É—Ä—Å–æ—Ä–∞
    container.addEventListener('mousemove', (e) => {
      const rect = container.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      socket.emit('cursor-move', { roomId, x, y, color: myColor });
      drawMyCursor(x, y);
    });

    container.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const rect = container.getBoundingClientRect();
      const x = e.touches[0].clientX - rect.left;
      const y = e.touches[0].clientY - rect.top;
      socket.emit('cursor-move', { roomId, x, y, color: myColor });
    });

    function executeInput(input) {
      // –°–∏–º—É–ª—è—Ü–∏—è –∫–ª–∏–∫–∞ —Å –º–∞—Å—à—Ç–∞–±–æ–º
      const realX = input.x / scale;
      const realY = input.y / scale;
      
      const event = new MouseEvent('click', {
        clientX: realX,
        clientY: realY,
        bubbles: true
      });
      document.elementFromPoint(realX, realY)?.dispatchEvent(event);
    }

    function drawMyCursor(x, y) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = myColor;
      ctx.beginPath();
      ctx.arc(x, y, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.font = 'bold 10px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('YOU', x, y - 12);
    }

    function drawRemoteCursor(data) {
      ctx.fillStyle = data.color;
      ctx.beginPath();
      ctx.arc(data.x, data.y, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.fillText(data.id.slice(-2), data.x, data.y - 12);
    }

    // Socket —Å–æ–±—ã—Ç–∏—è
    socket.on('all-users', (userIds) => {
      document.getElementById('status').textContent = `‚úÖ –ö–æ–º–Ω–∞—Ç–∞ ${roomId} –≥–æ—Ç–æ–≤–∞`;
      document.getElementById('startScreenBtn').disabled = false;
    });

    socket.on('user-joined', (data) => {
      document.getElementById('users').textContent = data.users;
      document.getElementById('myColor').textContent = data.color;
      myColor = data.color;
    });

    socket.on('offer', async (data) => {
      myPeer = createPeerConnection(data.sender);
      await myPeer.setRemoteDescription(data.offer);
      const answer = await myPeer.createAnswer();
      await myPeer.setLocalDescription(answer);
      socket.emit('answer', { targetId: data.sender, answer });
    });

    socket.on('answer', (data) => {
      myPeer.setRemoteDescription(data.answer);
    });

    socket.on('ice-candidate', (data) => {
      myPeer.addIceCandidate(data.candidate);
    });

    socket.on('remote-input', executeInput);
    socket.on('remote-cursor', drawRemoteCursor);

    function sendChat() {
      const msg = document.getElementById('chatInput').value.trim();
      if (msg) {
        socket.emit('chat-message', { roomId, message: `${myColor.slice(1).toUpperCase()}: ${msg}` });
        document.getElementById('chatInput').value = '';
      }
    }

    function handleEnter(event) {
      if (event.key === 'Enter') sendChat();
    }

    // –ö–æ–ª–µ—Å–æ –º—ã—à–∏ –¥–ª—è –∑—É–º–∞
    container.addEventListener('wheel', (e) => {
      e.preventDefault();
      scale *= e.deltaY > 0 ? 0.9 : 1.1;
      scale = Math.max(0.5, Math.min(scale, 3));
      video.style.transform = `scale(${scale})`;
    });
  </script>
</body>
</html>
